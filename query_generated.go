// Code generated by "internal/gen/query_gen.go"; DO NOT EDIT.

package ecs

// Query2 performs a query for the intersection of 2 components.
//
// It returns a packed slice of entities which have all components but not
// their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of a component type)
func Query2[
	// Intersect
	A Component,
	B Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	es := make([]Entity, 0)
	if !(okA && okB) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	minLen := min(lenA, lenB)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if storeB.entityIndices.At(int(e.ID())) >= 0 {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if storeA.entityIndices.At(int(e.ID())) >= 0 {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query2Exclude1 performs a query for the intersection of the first 2 components
// exluding the following 1 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query2Exclude1[
	// Intersect
	A Component,
	B Component,
	// Exclude
	C Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	es := make([]Entity, 0)
	if !(okA && okB && okC) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	minLen := min(lenA, lenB)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query2Exclude2 performs a query for the intersection of the first 2 components
// exluding the following 2 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query2Exclude2[
	// Intersect
	A Component,
	B Component,
	// Exclude
	C Component,
	D Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	minLen := min(lenA, lenB)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) < 0) && (storeD.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) < 0) && (storeD.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query2Exclude3 performs a query for the intersection of the first 2 components
// exluding the following 3 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query2Exclude3[
	// Intersect
	A Component,
	B Component,
	// Exclude
	C Component,
	D Component,
	E Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	minLen := min(lenA, lenB)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) < 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) < 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query2Exclude4 performs a query for the intersection of the first 2 components
// exluding the following 4 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query2Exclude4[
	// Intersect
	A Component,
	B Component,
	// Exclude
	C Component,
	D Component,
	E Component,
	F Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	minLen := min(lenA, lenB)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) < 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) < 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query2Exclude5 performs a query for the intersection of the first 2 components
// exluding the following 5 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query2Exclude5[
	// Intersect
	A Component,
	B Component,
	// Exclude
	C Component,
	D Component,
	E Component,
	F Component,
	G Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	minLen := min(lenA, lenB)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) < 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) < 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query2Exclude6 performs a query for the intersection of the first 2 components
// exluding the following 6 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query2Exclude6[
	// Intersect
	A Component,
	B Component,
	// Exclude
	C Component,
	D Component,
	E Component,
	F Component,
	G Component,
	H Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	minLen := min(lenA, lenB)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) < 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) < 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query3 performs a query for the intersection of 3 components.
//
// It returns a packed slice of entities which have all components but not
// their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of a component type)
func Query3[
	// Intersect
	A Component,
	B Component,
	C Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	es := make([]Entity, 0)
	if !(okA && okB && okC) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	minLen := min(lenA, lenB, lenC)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query3Exclude1 performs a query for the intersection of the first 3 components
// exluding the following 1 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query3Exclude1[
	// Intersect
	A Component,
	B Component,
	C Component,
	// Exclude
	D Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	minLen := min(lenA, lenB, lenC)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query3Exclude2 performs a query for the intersection of the first 3 components
// exluding the following 2 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query3Exclude2[
	// Intersect
	A Component,
	B Component,
	C Component,
	// Exclude
	D Component,
	E Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	minLen := min(lenA, lenB, lenC)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query3Exclude3 performs a query for the intersection of the first 3 components
// exluding the following 3 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query3Exclude3[
	// Intersect
	A Component,
	B Component,
	C Component,
	// Exclude
	D Component,
	E Component,
	F Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	minLen := min(lenA, lenB, lenC)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query3Exclude4 performs a query for the intersection of the first 3 components
// exluding the following 4 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query3Exclude4[
	// Intersect
	A Component,
	B Component,
	C Component,
	// Exclude
	D Component,
	E Component,
	F Component,
	G Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	minLen := min(lenA, lenB, lenC)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query3Exclude5 performs a query for the intersection of the first 3 components
// exluding the following 5 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query3Exclude5[
	// Intersect
	A Component,
	B Component,
	C Component,
	// Exclude
	D Component,
	E Component,
	F Component,
	G Component,
	H Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	minLen := min(lenA, lenB, lenC)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query3Exclude6 performs a query for the intersection of the first 3 components
// exluding the following 6 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query3Exclude6[
	// Intersect
	A Component,
	B Component,
	C Component,
	// Exclude
	D Component,
	E Component,
	F Component,
	G Component,
	H Component,
	I Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	var noopI I
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	storeI, okI := w.components[noopI.ID()].(*componentStore[I])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH && okI) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	minLen := min(lenA, lenB, lenC)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) < 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query4 performs a query for the intersection of 4 components.
//
// It returns a packed slice of entities which have all components but not
// their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of a component type)
func Query4[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	minLen := min(lenA, lenB, lenC, lenD)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query4Exclude1 performs a query for the intersection of the first 4 components
// exluding the following 1 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query4Exclude1[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	// Exclude
	E Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	minLen := min(lenA, lenB, lenC, lenD)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query4Exclude2 performs a query for the intersection of the first 4 components
// exluding the following 2 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query4Exclude2[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	// Exclude
	E Component,
	F Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	minLen := min(lenA, lenB, lenC, lenD)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query4Exclude3 performs a query for the intersection of the first 4 components
// exluding the following 3 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query4Exclude3[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	// Exclude
	E Component,
	F Component,
	G Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	minLen := min(lenA, lenB, lenC, lenD)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query4Exclude4 performs a query for the intersection of the first 4 components
// exluding the following 4 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query4Exclude4[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	// Exclude
	E Component,
	F Component,
	G Component,
	H Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	minLen := min(lenA, lenB, lenC, lenD)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query4Exclude5 performs a query for the intersection of the first 4 components
// exluding the following 5 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query4Exclude5[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	// Exclude
	E Component,
	F Component,
	G Component,
	H Component,
	I Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	var noopI I
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	storeI, okI := w.components[noopI.ID()].(*componentStore[I])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH && okI) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	minLen := min(lenA, lenB, lenC, lenD)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query4Exclude6 performs a query for the intersection of the first 4 components
// exluding the following 6 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query4Exclude6[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	// Exclude
	E Component,
	F Component,
	G Component,
	H Component,
	I Component,
	J Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	var noopI I
	var noopJ J
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	storeI, okI := w.components[noopI.ID()].(*componentStore[I])
	storeJ, okJ := w.components[noopJ.ID()].(*componentStore[J])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH && okI && okJ) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	minLen := min(lenA, lenB, lenC, lenD)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) < 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query5 performs a query for the intersection of 5 components.
//
// It returns a packed slice of entities which have all components but not
// their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of a component type)
func Query5[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query5Exclude1 performs a query for the intersection of the first 5 components
// exluding the following 1 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query5Exclude1[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
	// Exclude
	F Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query5Exclude2 performs a query for the intersection of the first 5 components
// exluding the following 2 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query5Exclude2[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
	// Exclude
	F Component,
	G Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query5Exclude3 performs a query for the intersection of the first 5 components
// exluding the following 3 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query5Exclude3[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
	// Exclude
	F Component,
	G Component,
	H Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query5Exclude4 performs a query for the intersection of the first 5 components
// exluding the following 4 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query5Exclude4[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
	// Exclude
	F Component,
	G Component,
	H Component,
	I Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	var noopI I
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	storeI, okI := w.components[noopI.ID()].(*componentStore[I])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH && okI) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query5Exclude5 performs a query for the intersection of the first 5 components
// exluding the following 5 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query5Exclude5[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
	// Exclude
	F Component,
	G Component,
	H Component,
	I Component,
	J Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	var noopI I
	var noopJ J
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	storeI, okI := w.components[noopI.ID()].(*componentStore[I])
	storeJ, okJ := w.components[noopJ.ID()].(*componentStore[J])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH && okI && okJ) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query5Exclude6 performs a query for the intersection of the first 5 components
// exluding the following 6 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query5Exclude6[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
	// Exclude
	F Component,
	G Component,
	H Component,
	I Component,
	J Component,
	K Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	var noopI I
	var noopJ J
	var noopK K
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	storeI, okI := w.components[noopI.ID()].(*componentStore[I])
	storeJ, okJ := w.components[noopJ.ID()].(*componentStore[J])
	storeK, okK := w.components[noopK.ID()].(*componentStore[K])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH && okI && okJ && okK) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) < 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query6 performs a query for the intersection of 6 components.
//
// It returns a packed slice of entities which have all components but not
// their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of a component type)
func Query6[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
	F Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	lenF := len(storeF.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE, lenF)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	case lenF:
		for _, e := range storeF.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query6Exclude1 performs a query for the intersection of the first 6 components
// exluding the following 1 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query6Exclude1[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
	F Component,
	// Exclude
	G Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	lenF := len(storeF.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE, lenF)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenF:
		for _, e := range storeF.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query6Exclude2 performs a query for the intersection of the first 6 components
// exluding the following 2 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query6Exclude2[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
	F Component,
	// Exclude
	G Component,
	H Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	lenF := len(storeF.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE, lenF)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenF:
		for _, e := range storeF.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query6Exclude3 performs a query for the intersection of the first 6 components
// exluding the following 3 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query6Exclude3[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
	F Component,
	// Exclude
	G Component,
	H Component,
	I Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	var noopI I
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	storeI, okI := w.components[noopI.ID()].(*componentStore[I])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH && okI) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	lenF := len(storeF.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE, lenF)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenF:
		for _, e := range storeF.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query6Exclude4 performs a query for the intersection of the first 6 components
// exluding the following 4 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query6Exclude4[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
	F Component,
	// Exclude
	G Component,
	H Component,
	I Component,
	J Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	var noopI I
	var noopJ J
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	storeI, okI := w.components[noopI.ID()].(*componentStore[I])
	storeJ, okJ := w.components[noopJ.ID()].(*componentStore[J])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH && okI && okJ) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	lenF := len(storeF.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE, lenF)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenF:
		for _, e := range storeF.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query6Exclude5 performs a query for the intersection of the first 6 components
// exluding the following 5 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query6Exclude5[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
	F Component,
	// Exclude
	G Component,
	H Component,
	I Component,
	J Component,
	K Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	var noopI I
	var noopJ J
	var noopK K
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	storeI, okI := w.components[noopI.ID()].(*componentStore[I])
	storeJ, okJ := w.components[noopJ.ID()].(*componentStore[J])
	storeK, okK := w.components[noopK.ID()].(*componentStore[K])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH && okI && okJ && okK) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	lenF := len(storeF.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE, lenF)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenF:
		for _, e := range storeF.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}

// Query6Exclude6 performs a query for the intersection of the first 6 components
// exluding the following 6 components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
func Query6Exclude6[
	// Intersect
	A Component,
	B Component,
	C Component,
	D Component,
	E Component,
	F Component,
	// Exclude
	G Component,
	H Component,
	I Component,
	J Component,
	K Component,
	L Component,
](w *World) []Entity {
	var noopA A
	var noopB B
	var noopC C
	var noopD D
	var noopE E
	var noopF F
	var noopG G
	var noopH H
	var noopI I
	var noopJ J
	var noopK K
	var noopL L
	storeA, okA := w.components[noopA.ID()].(*componentStore[A])
	storeB, okB := w.components[noopB.ID()].(*componentStore[B])
	storeC, okC := w.components[noopC.ID()].(*componentStore[C])
	storeD, okD := w.components[noopD.ID()].(*componentStore[D])
	storeE, okE := w.components[noopE.ID()].(*componentStore[E])
	storeF, okF := w.components[noopF.ID()].(*componentStore[F])
	storeG, okG := w.components[noopG.ID()].(*componentStore[G])
	storeH, okH := w.components[noopH.ID()].(*componentStore[H])
	storeI, okI := w.components[noopI.ID()].(*componentStore[I])
	storeJ, okJ := w.components[noopJ.ID()].(*componentStore[J])
	storeK, okK := w.components[noopK.ID()].(*componentStore[K])
	storeL, okL := w.components[noopL.ID()].(*componentStore[L])
	es := make([]Entity, 0)
	if !(okA && okB && okC && okD && okE && okF && okG && okH && okI && okJ && okK && okL) {
		return es
	}
	lenA := len(storeA.entityList)
	lenB := len(storeB.entityList)
	lenC := len(storeC.entityList)
	lenD := len(storeD.entityList)
	lenE := len(storeE.entityList)
	lenF := len(storeF.entityList)
	minLen := min(lenA, lenB, lenC, lenD, lenE, lenF)
	switch minLen {
	case lenA:
		for _, e := range storeA.entityList {
			if (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) && (storeL.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenB:
		for _, e := range storeB.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) && (storeL.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenC:
		for _, e := range storeC.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) && (storeL.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenD:
		for _, e := range storeD.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) && (storeL.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenE:
		for _, e := range storeE.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeF.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) && (storeL.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	case lenF:
		for _, e := range storeF.entityList {
			if (storeA.entityIndices.At(int(e.ID())) >= 0) && (storeB.entityIndices.At(int(e.ID())) >= 0) && (storeC.entityIndices.At(int(e.ID())) >= 0) && (storeD.entityIndices.At(int(e.ID())) >= 0) && (storeE.entityIndices.At(int(e.ID())) >= 0) && (storeG.entityIndices.At(int(e.ID())) < 0) && (storeH.entityIndices.At(int(e.ID())) < 0) && (storeI.entityIndices.At(int(e.ID())) < 0) && (storeJ.entityIndices.At(int(e.ID())) < 0) && (storeK.entityIndices.At(int(e.ID())) < 0) && (storeL.entityIndices.At(int(e.ID())) < 0) {
				es = append(es, e)
			}
		}
	}
	return es
}
