//go:build ignore

package main

import (
	"flag"
	"fmt"
	"os"
)

var typeParams = [26]rune{}

func main() {
    queryPtr := flag.Int("N", 2, "max components queried: 2 <= N <= 26.")

    flag.Parse()

    N := *queryPtr

    if N < 2 || N > 26 {
        fmt.Println("2 <= N <= 26.")
        return
    }

    i := 0
    for r := 'A'; r <= 'Z'; r++ {
        typeParams[i] = r 
        i++
    }

    fmt.Printf("Generating Queries up to %d components...\n", N)

    fo, err := os.Create("query_generated.go")
    if err != nil {
        panic(err)
    }
    defer func() {
        if err := fo.Close(); err != nil {
            panic(err)
        }
    }()

    fo.WriteString("// Code generated by \"internal/gen/query_gen.go\"; DO NOT EDIT.\n\n")
    fo.WriteString(fmt.Sprintf("package %s\n\n", os.Getenv("GOPACKAGE")))

    for q := 2; q <= N; q++ {
        for e := 0; e <= min(N, (26 - q)); e++ {
            gen_query(fo, q, e)
        }
    }
}

func gen_query(fo *os.File, q, e int) {
    queryName := ""
    queryComment := ""

    queryName += fmt.Sprintf("Query%d", q)

    if e > 0 {
        queryName += fmt.Sprintf("Exclude%d", e)
        queryComment = fmt.Sprintf(
`// %s performs a query for the intersection of the first %d components
// exluding the following %d components listed.
//
// It returns a packed slice of entities which have the queried components
// but not their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of intersected components)
`, queryName, q, e)
    } else {
        queryComment = fmt.Sprintf(
`// %s performs a query for the intersection of %d components.
//
// It returns a packed slice of entities which have all components but not
// their associated data. Paired with GetMut to mutate data.
//
// Time Complexity: O(N) where N = min(# Entities of a component type)
`, queryName, q)
    }

    // COMMENT
    fo.WriteString(queryComment)

    // HEADER
    paramCount := q+e

    fo.WriteString(fmt.Sprintf("func %s[\n", queryName))
    fo.WriteString("    // Intersect\n")
    for i := 0; i < q; i++ {
        fo.WriteString(fmt.Sprintf("    %c Component,\n", typeParams[i]))
    } 
    if e > 0 {
        fo.WriteString("    // Exclude\n")
    }
    for i := q; i < paramCount; i++ {
        fo.WriteString(fmt.Sprintf("    %c Component,\n", typeParams[i]))
    } 
    fo.WriteString("](w *World) []Entity {\n")

    // BODY
    for i := 0; i < paramCount; i++ {
        p := typeParams[i]
        fo.WriteString(fmt.Sprintf("    var noop%c %c\n", p, p))
    } 
    for i := 0; i < paramCount; i++ {
        p := typeParams[i]
        fo.WriteString(fmt.Sprintf("    store%c, ok%c := w.components[noop%c.ID()].(*componentStore[%c])\n",p,p,p,p))
    } 
    fo.WriteString("    es := make([]Entity, 0)\n")
    fo.WriteString("    if !(okA")
    for i := 1; i < paramCount; i++ {
        p := typeParams[i]
        fo.WriteString(fmt.Sprintf(" && ok%c", p))
    } 
    fo.WriteString(") {\n        return es\n    }\n")
    for i := 0; i < q; i++ {
        p := typeParams[i]
        fo.WriteString(fmt.Sprintf("    len%c := len(store%c.entityList)\n", p, p))
    } 
    fo.WriteString("    minLen := min(lenA")
    for i := 1; i < q; i++ {
        p := typeParams[i]
        fo.WriteString(fmt.Sprintf(", len%c", p))
    } 
    fo.WriteString(")\n")

    // SWITCH
    fo.WriteString("    switch minLen {\n")
    for i := 0; i < q; i++ {
        p := typeParams[i]
        fo.WriteString(fmt.Sprintf("    case len%c:\n", p))
        fo.WriteString(indent(fmt.Sprintf("for _, e := range store%c.entityList {\n", p), 2))
        fo.WriteString(indent("if ", 3))
        ifStr := ""
        for j := 0; j < q; j++ {
            if j == i { continue }
            typeExists :=fmt.Sprintf("(store%c.entityIndices.At(int(e.ID())) >= 0)", typeParams[j])
            ifStr += fmt.Sprintf("%s && ", typeExists)
        }
        for j := q; j < paramCount; j++ {
            notTypeExists :=fmt.Sprintf("(store%c.entityIndices.At(int(e.ID())) < 0)", typeParams[j])
            ifStr += fmt.Sprintf("%s && ", notTypeExists)
        }
        ifStr = ifStr[:len(ifStr)-3] + "{\n" + indent("es = append(es, e)\n", 4)
        ifStr += indent("}\n", 3)
        fo.WriteString(ifStr)
        fo.WriteString(indent("}\n", 2))
    } 
        fo.WriteString(indent("}\n", 1))

    fo.WriteString("    return es\n}\n")
}

func indent(s string, n int) string {
    for range n {
        s = "    " + s
    }
    return s
}
